# streamlit_app.py
import streamlit as st
import pandas as pd
import joblib
import matplotlib.pyplot as plt
import seaborn as sns
import os

# --- Streamlit Page Configuration ---
st.set_page_config(
    page_title="Fertilizer Recommendation System",
    page_icon="ðŸŒ±", # A small plant icon for the browser tab
    layout="wide", # Use a wide layout for better visualization space
    initial_sidebar_state="expanded" # Keep the sidebar open by default
)

# --- Function to Load Model and Data (Cached for Performance) ---
# @st.cache_resource decorator ensures that this function runs only once
# and its results are cached, improving app performance on subsequent reruns.
@st.cache_resource
def load_model_and_data():
    """
    Loads the trained machine learning model, target classes, feature information,
    and the original training dataset.
    """
    model_path = 'models/fertilizer_prediction_model.joblib'
    target_classes_path = 'models/target_classes.joblib'
    feature_info_path = 'models/feature_info.joblib'
    data_path = 'fertilizer_training_dataset_3000.csv'

    # Check if model files exist before attempting to load
    if not os.path.exists('models') or not os.path.exists(model_path):
        st.error("Model files not found. Please run `model_training.py` first to train and save the model.")
        st.stop() # Stop the Streamlit app if files are missing

    try:
        model = joblib.load(model_path)
        target_classes = joblib.load(target_classes_path)
        feature_info = joblib.load(feature_info_path)
        df_train = pd.read_csv(data_path)
        return model, target_classes, feature_info, df_train
    except Exception as e:
        st.error(f"Error loading model or data: {e}")
        st.info("Ensure all files are correctly saved in the 'models' directory and 'fertilizer_training_dataset_3000.csv' is in the app directory.")
        st.stop() # Stop the app on loading errors

# Load all necessary components
model, target_classes, feature_info, df_train = load_model_and_data()

# Extract feature names and unique categories from the loaded feature_info
numerical_features = feature_info['numerical_features']
categorical_features = feature_info['categorical_features']
soil_colors = feature_info['soil_colors']
crop_types = feature_info['crop_types']

# --- Helper Function to Get Feature Importance ---
def get_feature_importance(model_pipeline, numerical_features, categorical_features):
    """
    Extracts and returns feature importances from the RandomForestClassifier
    within the pipeline, mapping them to original and one-hot encoded feature names.
    """
    # Access the preprocessor and classifier steps from the pipeline
    preprocessor = model_pipeline.named_steps['preprocessor']
    classifier = model_pipeline.named_steps['classifier']

    # Get the feature names generated by the OneHotEncoder
    ohe_feature_names = preprocessor.named_transformers_['cat'].get_feature_names_out(categorical_features)
    
    # Combine original numerical feature names with one-hot encoded categorical feature names
    all_feature_names = numerical_features + list(ohe_feature_names)

    # Create a DataFrame for feature importances
    if len(classifier.feature_importances_) != len(all_feature_names):
        st.warning("Mismatch in feature importance length and feature names. Feature importance visualization might be inaccurate.")
        return pd.DataFrame()

    feature_importances = pd.DataFrame({
        'Feature': all_feature_names,
        'Importance': classifier.feature_importances_
    }).sort_values(by='Importance', ascending=False)
    return feature_importances

# --- Sidebar for Navigation and Information ---
with st.sidebar:
    st.header("About This App")
    st.write("This application provides fertilizer recommendations based on various soil and crop parameters using a trained Machine Learning model.")
    st.markdown("---")
    st.subheader("Model Details")
    st.write(f"**Model Type:** RandomForestClassifier")
    st.write(f"**Training Data Size:** {df_train.shape[0]} samples")
    st.write("The model predicts the optimal fertilizer type for your specific conditions.")
    st.markdown("---")
    st.subheader("How to Use")
    st.write("1. Adjust the input parameters on the main page.")
    st.write("2. Click 'Predict Fertilizer' to get a recommendation.")
    st.write("3. Explore the 'Model Insights' section for data visualizations and feature importance.")
    st.markdown("---")
    st.info("Developed as a learning project for ML model deployment.")


# --- Main Application Title and Description ---
st.title("ðŸŒ± Fertilizer Recommendation System")
st.markdown("""
    Welcome to the Fertilizer Recommendation System!
    Input your soil and crop details below to receive a personalized fertilizer recommendation.
    This system leverages a Machine Learning model trained on a comprehensive dataset to provide accurate suggestions.
""")
st.markdown("---")

# --- Input Section for User Parameters ---
st.header("Input Parameters")

col1, col2, col3 = st.columns(3)

with col1:
    st.subheader("Nutrient Levels")
    nitrogen = st.slider("Nitrogen (N) Content", 0, 200, 95, help="Amount of Nitrogen in the soil (e.g., ppm)")
    phosphorus = st.slider("Phosphorus (P) Content", 0, 150, 45, help="Amount of Phosphorus in the soil (e.g., ppm)")
    potassium = st.slider("Potassium (K) Content", 0, 200, 40, help="Amount of Potassium in the soil (e.g., ppm)")

with col2:
    st.subheader("Environmental Factors")
    ph = st.slider("pH Value", 0.0, 14.0, 6.5, 0.1, help="Soil pH, indicating acidity or alkalinity")
    rainfall = st.slider("Rainfall (mm)", 0, 2000, 1000, help="Average annual rainfall in millimeters")
    temperature = st.slider("Temperature (Â°C)", 0, 50, 25, help="Average temperature in Celsius")

with col3:
    st.subheader("Soil & Crop Details")
    soil_color = st.selectbox("Soil Color", soil_colors, help="Select the dominant color of your soil")
    crop_type = st.selectbox("Crop Type", crop_types, help="Select the type of crop you intend to grow")

# --- Prediction Button ---
st.markdown("---")
if st.button("Predict Fertilizer", help="Click to get the fertilizer recommendation based on your inputs"):
    input_data = pd.DataFrame([[nitrogen, phosphorus, potassium, ph, rainfall, temperature, soil_color, crop_type]],
                              columns=numerical_features + categorical_features)

    try:
        prediction = model.predict(input_data)[0]
        st.success(f"The recommended fertilizer is: **{prediction}**")

        st.subheader("Prediction Confidence")
        probabilities = model.predict_proba(input_data)[0]
        prob_df = pd.DataFrame({
            'Fertilizer': target_classes,
            'Probability': probabilities
        }).sort_values(by='Probability', ascending=False)

        fig_prob, ax_prob = plt.subplots(figsize=(10, 6))
        sns.barplot(x='Probability', y='Fertilizer', data=prob_df, palette='viridis', ax=ax_prob)
        ax_prob.set_title('Probability Distribution for Prediction')
        ax_prob.set_xlabel('Probability')
        ax_prob.set_ylabel('Fertilizer Type')
        st.pyplot(fig_prob)
        st.write("This chart shows the model's confidence for each possible fertilizer type.")

    except Exception as e:
        st.error(f"An error occurred during prediction: {e}")
        st.info("Please ensure all input fields are valid and the model is correctly loaded and trained.")

st.markdown("---")

# --- Model Insights Section ---
st.header("Model Insights & Data Visualizations")

# 1. Distribution of Fertilizers in Training Data
st.subheader("1. Distribution of Fertilizers in Training Data")
fig_dist, ax_dist = plt.subplots(figsize=(12, 7))
sns.countplot(y=df_train['Fertilizer'], order=df_train['Fertilizer'].value_counts().index, palette='coolwarm', ax=ax_dist)
ax_dist.set_title('Distribution of Fertilizer Types in Training Data')
ax_dist.set_xlabel('Count')
ax_dist.set_ylabel('Fertilizer Type')
st.pyplot(fig_dist)
st.write("This chart illustrates the frequency of each fertilizer type in the dataset used to train the model. It gives an idea of the most common recommendations.")

# 2. Feature Importance from the Model
st.subheader("2. Feature Importance from the Model")
feature_importances_df = get_feature_importance(model, numerical_features, categorical_features)

if not feature_importances_df.empty:
    fig_imp, ax_imp = plt.subplots(figsize=(12, 7))
    sns.barplot(x='Importance', y='Feature', data=feature_importances_df, palette='magma', ax=ax_imp)
    ax_imp.set_title('Feature Importance for Fertilizer Prediction')
    ax_imp.set_xlabel('Importance (Higher Value = More Impact)')
    ax_imp.set_ylabel('Feature')
    st.pyplot(fig_imp)
    st.write("This chart shows which input features the RandomForestClassifier considered most important when making its predictions. Features with higher importance values had a greater impact on the model's decisions.")
else:
    st.warning("Could not retrieve feature importances. This is usually due to the model type not supporting `feature_importances_` (e.g., Linear Regression) or an internal error during feature name mapping.)")


# --- NEW ADDITION: 3. Correlation Heatmap ---
st.subheader("3. Correlation Heatmap of Numerical Features")
st.write("This heatmap shows the correlation between the numerical input features in the training data. Values closer to 1 or -1 indicate a strong positive or negative relationship, respectively. Values near 0 indicate a weak relationship.")

# Calculate the correlation matrix for only the numerical features
correlation_matrix = df_train[numerical_features].corr()

# Create the heatmap using seaborn
fig_corr, ax_corr = plt.subplots(figsize=(10, 8))
sns.heatmap(
    correlation_matrix,
    annot=True,      # Show the correlation values on the heatmap
    cmap='coolwarm', # Color map (diverging colors are good for correlations)
    fmt=".2f",       # Format annotations to two decimal places
    linewidths=.5,   # Add lines between cells
    ax=ax_corr
)
ax_corr.set_title('Correlation Heatmap of Numerical Features')
st.pyplot(fig_corr)
# --- END NEW ADDITION ---


st.markdown("---")
st.info("Thank you for using the Fertilizer Recommendation System!")
